const board = {

    a1 : { 
        piece: "rock",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhiteRock.svg"
    },
    b1 : { 
        piece: "knight",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhiteKnight.svg"
    },
    c1 : { 
        piece: "bishop",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhiteBishop.svg"
    },
    d1 : { 
        piece: "queen",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhiteQueen.svg"
    },
    e1 : { 
        piece: "king",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhiteKing.svg"
    },
    f1 : { 
        piece: "bishop",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhiteBishop.svg"
    },
    g1 : { 
        piece: "knight",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhiteKnight.svg"
    },
    h1 : { 
        piece: "rock",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhiteRock.svg"
    },
    a2 : { 
        piece: "pawn",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhitePawn.svg"
    },
    b2 : { 
        piece: "pawn",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhitePawn.svg"
    },
    c2 : { 
        piece: "pawn",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhitePawn.svg"
    },
    d2 : { 
        piece: "pawn",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhitePawn.svg"
    },
    e2 : { 
        piece: "pawn",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhitePawn.svg"
    },
    f2 : { 
        piece: "pawn",
        color: "white",
        hasMoved : false,
        source: "./Resources/WhitePawn.svg"
    },
    g2 : { 
        piece: "pawn",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhitePawn.svg"
    },
    h2 : { 
        piece: "pawn",
        color: "white",
        hasMoved : false,
        source: "../Resources/WhitePawn.svg"
    },
    a3 : { 
        piece: "",
        color: ""
    },
    b3 : { 
        piece: "",
        color: ""
    },
    c3 : { 
        piece: "",
        color: ""
    },
    d3 : { 
        piece: "",
        color: ""
    },
    e3 : { 
        piece: "",
        color: ""
    },
    f3 : { 
        piece: "",
        color: ""
    },
    g3 : { 
        piece: "",
        color: ""
    },
    h3 : { 
        piece: "",
        color: ""
    },
    a4 : { 
        piece: "",
        color: ""
    },
    b4 : { 
        piece: "",
        color: ""
    },
    c4 : { 
        piece: "",
        color: ""
    },
    d4 : { 
        piece: "",
        color: ""
    },
    e4 : { 
        piece: "",
        color: ""
    },
    f4 : { 
        piece: "",
        color: ""
    },
    g4 : { 
        piece: "",
        color: ""
    },
    h4 : { 
        piece: "",
        color: ""
    },
    a5 : { 
        piece: "",
        color: ""
    },
    b5 : { 
        piece: "",
        color: ""
    },
    c5 : { 
        piece: "",
        color: ""
    },
    d5 : { 
        piece: "",
        color: ""
    },
    e5 : { 
        piece: "",
        color: ""
    },
    f5 : { 
        piece: "",
        color: ""
    },
    g5 : { 
        piece: "",
        color: ""
    },
    h5 : { 
        piece: "",
        color: ""
    },
    a6 : { 
        piece: "",
        color: ""
    },
    b6 : { 
        piece: "",
        color: ""
    },
    c6 : { 
        piece: "",
        color: ""
    },
    d6 : { 
        piece: "",
        color: ""
    },
    e6 : { 
        piece: "",
        color: ""
    },
    f6 : { 
        piece: "",
        color: ""
    },
    g6 : { 
        piece: "",
        color: ""
    },
    h6 : { 
        piece: "",
        color: ""
    },
    a7 : { 
        piece: "pawn",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackPawn.svg"
    },
    b7 : { 
        piece: "pawn",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackPawn.svg"
    },
    c7 : { 
        piece: "pawn",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackPawn.svg"
    },
    d7 : { 
        piece: "pawn",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackPawn.svg"
    },
    e7 : { 
        piece: "pawn",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackPawn.svg"
    },
    f7 : { 
        piece: "pawn",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackPawn.svg"
    },
    g7 : { 
        piece: "pawn",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackPawn.svg"
    },
    h7 : { 
        piece: "pawn",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackPawn.svg"
    },
    a8 : { 
        piece: "rock",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackRock.svg"
    },
    b8 : { 
        piece: "knight",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackKnight.svg"
    },
    c8 : { 
        piece: "bishop",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackBishop.svg"
    },
    d8 : { 
        piece: "queen",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackQueen.svg"
    },
    e8 : { 
        piece: "king",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackKing.svg"
    },
    f8 : { 
        piece: "bishop",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackBishop.svg"
    },
    g8 : { 
        piece: "knight",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackKnight.svg"
    },
    h8 : { 
        piece: "rock",
        color: "black",
        hasMoved : false,
        source: "../Resources/BlackRock.svg"
    },


    updateBoard (tile1, tile2) {
        this[tile2].piece = this[tile1].piece;
        this[tile2].color = this[tile1].color;
        this[tile2].source = this[tile1].source;
        this[tile2].hasMoved = true;
        this[tile1].piece = "";
        this[tile1].color = "";
        this[tile1].source = "";
        },

    updateBoardForCheck (tile1, tile2) {
        let colorTosave = this[tile2].color;
        let pieceTosave = this[tile2].piece;
        let sourceTosave = this[tile2].source;
        this[tile2].piece = this[tile1].piece;
        this[tile2].color = this[tile1].color;
        this[tile2].source = this[tile1].source;
        this[tile2].hasMoved = false;
        this[tile1].piece = pieceTosave;
        this[tile1].color = colorTosave;
        this[tile1].source = sourceTosave; 
        this[tile1].hasMoved= false;
    },

    removePiece(tile) {
        this[tile].piece ="";
        this[tile].color ="";
        this[tile].source ="";
        this[tile].hasMoved ="";
    },

    addPiece(piece, color, source, hasMoved, tile) {
        this[tile].piece = piece;
        this[tile].color = color;
        this[tile].source = source;
        this[tile].hasMoved = hasMoved;
    }
}

const gameInfo = {
    turn: "white",
    piecesWhiteTook: [],
    piecesBlackTook: [],

    updateTurn () {
        if(this.turn == "white") {
            this.turn = "black"
        } else {
            this.turn = "white";
        }
    }
}

const renderBoard = ( ) => {

    const tiles = document.querySelectorAll(".tile");

    tiles.forEach( tile => {

        const tileToRender = tile.id;
        if(board[tileToRender].piece != "") {
            const pieceToRender = document.createElement("img")
            pieceToRender.src = board[tileToRender].source;
            pieceToRender.classList.add("piece");
            tile.append(pieceToRender);
        }

    })

}

const clearBoard = () => {

    const tiles = document.querySelectorAll(".tile");

    tiles.forEach( tile => { 
        if (tile.childNodes.length > 0 ) {
            tile.removeChild(tile.firstChild);
        }
    });
}

renderBoard();

const convertToXY = (piecePosition) => {

    let y = parseInt(piecePosition.charAt(1));

    switch(piecePosition[0]) {
        case("a"):
            return [1, y];
        case("b"):
            return [2, y];
        case("c"):
            return [3, y];
        case("d"):
            return [4, y];
        case("e"):
            return [5, y];
        case("f"):
            return [6, y];
        case("g"):
            return [7, y];
        case("h"):
            return [8, y];
    }
}

const convertXYtoBoardCoordinates= (XYPositions) => {
  
    let y = XYPositions[1];

    switch(XYPositions[0]) {
        case(1):
            return "a"+y;
        case(2):
            return "b"+y;
        case(3):
            return "c"+y;
        case(4):
            return "d"+y;
        case(5):
            return "e"+y;
        case(6):
            return "f"+y;
        case(7):
            return "g"+y;
        case(8):
            return "h"+y;
    }
}

const pawn = (currentPositionXY, pawnColor) => {
    
    let moves=[];

    if (pawnColor == "white") {
        const left = [currentPositionXY[0]-1, currentPositionXY[1]+1];
        const center = [currentPositionXY[0], currentPositionXY[1]+1];
        const right = [currentPositionXY[0]+1, currentPositionXY[1]+1];

        if (left[0]> 0 && left[1]<9) {
            if(board[convertXYtoBoardCoordinates(left)].color == "black") {
                moves.push(left);
            }
        }
        if (center[1]<9) {
            if(board[convertXYtoBoardCoordinates(center)].color == "") {
                moves.push(center);
            }
        }
        if (right[0]< 9 && right[1]<9) {
            if(board[convertXYtoBoardCoordinates(right)].color == "black") {
                moves.push(right);
            }
        }
        return moves;
    } else {
        const left = [currentPositionXY[0]-1, currentPositionXY[1]-1];
        const center = [currentPositionXY[0], currentPositionXY[1]-1];
        const right = [currentPositionXY[0]+1, currentPositionXY[1]-1];

        if (left[0]> 0 && left[1]>0) {
            if(board[convertXYtoBoardCoordinates(left)].color == "white") {
                moves.push(left);
            }
        }
        if (center[1]>0) {
            if(board[convertXYtoBoardCoordinates(center)].color == "") {
                moves.push(center);
            }
        }
        if (right[0]< 9 && right[1]>0) {
            if(board[convertXYtoBoardCoordinates(right)].color == "white") {
                moves.push(right);
            }
        }
        return moves;
    }
}

const movePawn = (currentPosition, pawnColor) => {
    
    const XYposition = convertToXY(currentPosition); 

    const ruleSetMoves = pawn(XYposition ,pawnColor);
    const ruleSetMovesToBoardCoordinates = ruleSetMoves.map (coordinates => convertXYtoBoardCoordinates(coordinates));
    
    const allowedMoves = ruleSetMovesToBoardCoordinates.filter( coordinate => board[coordinate].color != pawnColor);
    if(board[currentPosition].hasMoved == false) {
        if(pawnColor == "white") {
            const doubleStep = (convertXYtoBoardCoordinates([XYposition[0],XYposition[1]+2]));
            if(board[doubleStep].color == "") {
                allowedMoves.push(doubleStep);
            }
        } else {
            const doubleStep = (convertXYtoBoardCoordinates([XYposition[0],XYposition[1]-2]));
            if(board[doubleStep].color == "") {
                allowedMoves.push(doubleStep);
            }
        }
    }
    
    return allowedMoves;
}

const knight = (currentPositionXY) => {
    
        const moves = [[currentPositionXY[0]+1, currentPositionXY[1]+2],[currentPositionXY[0]+2, currentPositionXY[1]+1],[currentPositionXY[0]+2, currentPositionXY[1]-1],[currentPositionXY[0]+1, currentPositionXY[1]-2],[currentPositionXY[0]-1, currentPositionXY[1]-2],[currentPositionXY[0]-2, currentPositionXY[1]-1],[currentPositionXY[0]-2, currentPositionXY[1]+1],[currentPositionXY[0]-1, currentPositionXY[1]+2]]
    
        const regularMoves = moves.filter ( move => (move[0]> 0 && move[0]<9 && move[1]>0 && move[1] <9) );
        return regularMoves;
}

const king = (currentPositionXY) => {
    
    const moves = [[currentPositionXY[0], currentPositionXY[1]+1],[currentPositionXY[0]+1, currentPositionXY[1]+1],[currentPositionXY[0]+1, currentPositionXY[1]],[currentPositionXY[0]+1, currentPositionXY[1]-1],[currentPositionXY[0], currentPositionXY[1]-1],[currentPositionXY[0]-1, currentPositionXY[1]-1],[currentPositionXY[0]-1, currentPositionXY[1]],[currentPositionXY[0]-1, currentPositionXY[1]+1]]

    const regularMoves = moves.filter ( move => (move[0]> 0 && move[0]<9 && move[1]>0 && move[1] <9) );
    return regularMoves;
}

const findOpponentAllPossibleMoves = (color) => {

    if(color == "black") {

    const whitePiecesPositions = findPiecesOfSpecificColor("white");
        
    let whitePossibleMoves = [];

    whitePiecesPositions.forEach ( element => {
        switch(Object.values(element)[0]) {
            case("pawn"):
                whitePossibleMoves=whitePossibleMoves.concat(movePawn(Object.keys(element)[0], "white"));
                break;
            case("rock"):
                whitePossibleMoves=whitePossibleMoves.concat(moveRock(Object.keys(element)[0], "white"));
                break;
            case("bishop"):
                whitePossibleMoves=whitePossibleMoves.concat(moveBishop(Object.keys(element)[0], "white"));
                break;
            case("knight"):
                whitePossibleMoves=whitePossibleMoves.concat(moveKnight(Object.keys(element)[0], "white"));
                break;
            case("queen"):
                whitePossibleMoves=whitePossibleMoves.concat(moveQueen(Object.keys(element)[0], "white"));
                break;
        }
    });
    return whitePossibleMoves;
    } else {

        const blackPiecesPositions = findPiecesOfSpecificColor("black");
            
        let blackPossibleMoves = [];

        blackPiecesPositions.forEach ( element => {
            switch(Object.values(element)[0]) {
                case("pawn"):
                    blackPossibleMoves=blackPossibleMoves.concat(movePawn(Object.keys(element)[0], "black"));
                    break;
                case("rock"):
                    blackPossibleMoves=blackPossibleMoves.concat(moveRock(Object.keys(element)[0], "black"));
                    break;
                case("bishop"):
                    blackPossibleMoves=blackPossibleMoves.concat(moveBishop(Object.keys(element)[0], "black"));
                    break;
                case("knight"):
                    blackPossibleMoves=blackPossibleMoves.concat(moveKnight(Object.keys(element)[0], "black"));
                    break;
                case("queen"):
                    blackPossibleMoves=blackPossibleMoves.concat(moveQueen(Object.keys(element)[0], "black"));
                    break;
            }
        });
        return blackPossibleMoves;
    }

}

const moveKing = (currentPosition, pawnColor) => {
   
    const XYposition = convertToXY(currentPosition); 

    const ruleSetMoves = king(XYposition);
    const ruleSetMovesToBoardCoordinates = ruleSetMoves.map (coordinates => convertXYtoBoardCoordinates(coordinates));
    
    const allowedMoves = ruleSetMovesToBoardCoordinates.filter( coordinate => board[coordinate].color != pawnColor);

    const movesThatCauseCheck = checkIfMoved(currentPosition, pawnColor, allowedMoves);

    return allowedMoves;
}


const moveKnight = (currentPosition, pawnColor) => {
    
    const XYposition = convertToXY(currentPosition); 

    const ruleSetMoves = knight(XYposition);
    const ruleSetMovesToBoardCoordinates = ruleSetMoves.map (coordinates => convertXYtoBoardCoordinates(coordinates));
    
    const allowedMoves = ruleSetMovesToBoardCoordinates.filter( coordinate => board[coordinate].color != pawnColor);

    return allowedMoves;
}

const moveBishop = (currentPosition, pieceColor) => {
    
    const possibleMoves = [];
    const XYposition = convertToXY(currentPosition); 

    //Moves for North east diagonal
    for( let i=1; i < 8; i++) {
        const X = XYposition[0]+i;
        const Y = XYposition[1]+i;
        if( X > 8 || Y > 8 || X < 1 || Y < 1) {
            break;
        }
        const boardPosition = convertXYtoBoardCoordinates([X,Y]);
        if (board[boardPosition].color == pieceColor) {
            break;
        } else if (board[boardPosition].color == ""){
            possibleMoves.push(boardPosition);
        } else {
            possibleMoves.push(boardPosition);
            break;
        }
    }

    //Moves for South east diagonal
    for( let i=1; i < 8; i++) {
        const X = XYposition[0]+i;
        const Y = (XYposition[1]-i);
        if( X > 8 || Y > 8 || X < 1 || Y < 1) {
            break;
        }
        const boardPosition = convertXYtoBoardCoordinates([X,Y]);
        if (board[boardPosition].color == pieceColor) {
            break;
        } else if (board[boardPosition].color == ""){
            possibleMoves.push(boardPosition);
        } else {
            possibleMoves.push(boardPosition);
            break;
        }
    }

    //Moves for South west diagonal
    for( let i=1; i < 8; i++) {
        const X = (XYposition[0]-i);
        const Y = (XYposition[1]-i);
        if( X > 8 || Y > 8 || X < 1 || Y < 1) {
            break;
        }
        const boardPosition = convertXYtoBoardCoordinates([X,Y]);
        if (board[boardPosition].color == pieceColor) {
            break;
        } else if (board[boardPosition].color == ""){
            possibleMoves.push(boardPosition);
        } else {
            possibleMoves.push(boardPosition);
            break;
        }
    }

    //Moves for North west diagonal
    for( let i=1; i < 8; i++) {
        const X = (XYposition[0]-i);
        const Y = (XYposition[1]+i);
        if( X > 8 || Y > 8 || X < 1 || Y < 1) {
            break;
        }
        const boardPosition = convertXYtoBoardCoordinates([X,Y]);
        if (board[boardPosition].color == pieceColor) {
            break;
        } else if (board[boardPosition].color == ""){
            possibleMoves.push(boardPosition);
        } else {
            possibleMoves.push(boardPosition);
            break;
        }
    }

    return possibleMoves;
}

const moveRock = (currentPosition, pieceColor) => {
    
    const possibleMoves = [];
    const XYposition = convertToXY(currentPosition); 

    //North moves
    for( let i=1; i < 8; i++) {
        const X = XYposition[0];
        const Y = XYposition[1]+i;
        if( X > 8 || Y > 8 || X < 1 || Y < 1) {
            break;
        }
        const boardPosition = convertXYtoBoardCoordinates([X,Y]);
        if (board[boardPosition].color == pieceColor) {
            break;
        } else if (board[boardPosition].color == ""){
            possibleMoves.push(boardPosition);
        } else {
            possibleMoves.push(boardPosition);
            break;
        }
    }

    //East moves
    for( let i=1; i < 8; i++) {
        const X = XYposition[0]+i;
        const Y = (XYposition[1]);
        if( X > 8 || Y > 8 || X < 1 || Y < 1) {
            break;
        }
        const boardPosition = convertXYtoBoardCoordinates([X,Y]);
        if (board[boardPosition].color == pieceColor) {
            break;
        } else if (board[boardPosition].color == ""){
            possibleMoves.push(boardPosition);
        } else {
            possibleMoves.push(boardPosition);
            break;
        }
    }

    //South moves
    for( let i=1; i < 8; i++) {
        const X = XYposition[0];
        const Y = (XYposition[1]-i);
        if( X > 8 || Y > 8 || X < 1 || Y < 1) {
            break;
        }
        const boardPosition = convertXYtoBoardCoordinates([X,Y]);
        if (board[boardPosition].color == pieceColor) {
            break;
        } else if (board[boardPosition].color == ""){
            possibleMoves.push(boardPosition);
        } else {
            possibleMoves.push(boardPosition);
            break;
        }
    }

    //West moves
    for( let i=1; i < 8; i++) {
        const X = (XYposition[0]-i);
        const Y = XYposition[1];
        if( X > 8 || Y > 8 || X < 1 || Y < 1) {
            break;
        }
        const boardPosition = convertXYtoBoardCoordinates([X,Y]);
        if (board[boardPosition].color == pieceColor) {
            break;
        } else if (board[boardPosition].color == ""){
            possibleMoves.push(boardPosition);
        } else {
            possibleMoves.push(boardPosition);
            break;
        }
    }

    return possibleMoves;
}

const moveQueen = (currentPosition, pieceColor) => {
    
    let moves = moveBishop(currentPosition, pieceColor);
    let moves2 = moveRock(currentPosition, pieceColor);

    return moves.concat(moves2);

}

const renderMoves = (possibleMoves) => {

    const tiles = document.querySelectorAll(".tile");
    
    for(let i=0; i<tiles.length; i++) {
        if(possibleMoves.includes(tiles[i].id)) {
            const classes = tiles[i].class
            tiles[i].classList.add("active");
        }
    }

}

const clearActiveSelectedTiles = () => {

    const activeTiles = document.querySelectorAll(".active");
    const selectedPiece = document.querySelector(".selected");

    activeTiles.forEach( tile => tile.classList.remove("active"));
    selectedPiece.classList.remove("selected");

}

const renderTakenPieces = (piece, color) => {
    
    let renderingDiv;
    const pieceToRender = document.createElement("img");
    const pieceName = piece.charAt(0).toUpperCase() + piece.slice(1);

    if (color == "white") {
        renderingDiv = document.querySelector(".pieceBlackTook");
        pieceToRender.src = `../Resources/White${pieceName}.svg`;
        pieceToRender.classList.add("pieceTaken");
        renderingDiv.append(pieceToRender);
    } else {
        renderingDiv = document.querySelector(".pieceWhiteTook");
        pieceToRender.src = `../Resources/Black${pieceName}.svg`;
        pieceToRender.classList.add("pieceTaken");
        renderingDiv.append(pieceToRender);
    }
}

const findKingPosition = (color) => {

    for (key in board) {
        if(board[key].piece == "king" && board[key].color == color) {
            return key;
        }
    }
}

const findPiecesOfSpecificColor = (color) => {

	const piecesArr = [];

	for (keys in board) {
  
  	if(board[keys].color == color) {
    		piecesArr.push({[keys] : board[keys].piece});
    }
  }
  return piecesArr;
}

const check = (colorThatMovesLast) => {
    
    if(colorThatMovesLast == "white") {

        const blackKingPosition = findKingPosition("black");
        const whitePiecesPositions = findPiecesOfSpecificColor("white");
        
        let whitePossibleMoves = [];

        whitePiecesPositions.forEach ( element => {
            switch(Object.values(element)[0]) {
                case("pawn"):
                    whitePossibleMoves=whitePossibleMoves.concat(movePawn(Object.keys(element)[0], "white"));
                    break;
                case("rock"):
                    whitePossibleMoves=whitePossibleMoves.concat(moveRock(Object.keys(element)[0], "white"));
                    break;
                case("bishop"):
                    whitePossibleMoves=whitePossibleMoves.concat(moveBishop(Object.keys(element)[0], "white"));
                    break;
                case("knight"):
                    whitePossibleMoves=whitePossibleMoves.concat(moveKnight(Object.keys(element)[0], "white"));
                    break;
                case("queen"):
                    whitePossibleMoves=whitePossibleMoves.concat(moveQueen(Object.keys(element)[0], "white"));
                    break;
            }
        });
        if(whitePossibleMoves.includes(blackKingPosition)) {
            const kingTile = document.getElementById(blackKingPosition);
            kingTile.classList.add("checked");
            return true;
        }
    } else {

        const whiteKingPosition = findKingPosition("white");
        const blackPiecesPositions = findPiecesOfSpecificColor("black");
        
        let blackPossibleMoves = [];

        blackPiecesPositions.forEach ( element => {
            switch(Object.values(element)[0]) {
                case("pawn"):
                    blackPossibleMoves=blackPossibleMoves.concat(movePawn(Object.keys(element)[0], "black"));
                    break;
                case("rock"):
                    blackPossibleMoves=blackPossibleMoves.concat(moveRock(Object.keys(element)[0], "black"));
                    break;
                case("bishop"):
                    blackPossibleMoves=blackPossibleMoves.concat(moveBishop(Object.keys(element)[0], "black"));
                    break;
                case("knight"):
                    blackPossibleMoves=blackPossibleMoves.concat(moveKnight(Object.keys(element)[0], "black"));
                    break;
                case("queen"):
                    blackPossibleMoves=blackPossibleMoves.concat(moveQueen(Object.keys(element)[0], "black"));
                    break;
            }
        });
        if(blackPossibleMoves.includes(whiteKingPosition)) {
            const kingTile = document.getElementById(whiteKingPosition);
            kingTile.classList.add("checked");
            return true;
        }
    }

}

const checkIfMoved = (currentPosition, colorPiece, arrayOfMoves) => {
   
    const movesThatCauseCheck = [];
    const movesToCheck = [...arrayOfMoves];

    arrayOfMoves.forEach ( move => { 
        board.updateBoardForCheck(currentPosition, move);
        const opponentMoves = findOpponentAllPossibleMoves(colorPiece);
        const kingPosition = findKingPosition(colorPiece);
        if(opponentMoves.includes(kingPosition)) {
            movesThatCauseCheck.push(move);
        }
        board.updateBoardForCheck(move, currentPosition);
    });

    for(let i=0; i< movesThatCauseCheck.length; i++) {
        if((movesToCheck.includes(movesThatCauseCheck[i]))) {
            for(let y=0; y<movesToCheck.length;y++) {
                if(movesToCheck[y] == movesThatCauseCheck[i]) {
                    movesToCheck.splice(y,1);
                    y=0;
                }   
            }
        }
    }

    return movesToCheck;
}

const clearChecked = () => {

    const checkedKing = document.querySelector(".checked");
    if (checkedKing == null) {
        return;
    }

    checkedKing.classList.remove("checked");
    return;
}

const pieceClicled = (event) => {

    //Move piece on empty tiles
    if(event.target.classList.contains("active")) {
        const colorThatMoved = board[document.querySelector(".selected").id].color;
        board.updateBoard(document.querySelector(".selected").id, event.target.id);
        clearBoard();
        renderBoard();
        clearActiveSelectedTiles();
        gameInfo.updateTurn();
        clearChecked();
        check(colorThatMoved);
        return;
    }
    //Move piece and take another piece
    if(event.target.parentElement.classList.contains("active")) {
        console.log(event.target.parentElement.id);
        const colorThatMoved = board[document.querySelector(".selected").id].color;
        renderTakenPieces(board[event.target.parentElement.id].piece,board[event.target.parentElement.id].color);
        board.updateBoard(document.querySelector(".selected").id, event.target.parentElement.id);
        clearBoard();
        renderBoard();
        clearActiveSelectedTiles();
        gameInfo.updateTurn();
        clearChecked();
        check(colorThatMoved);
        return;
    }
    //Clear tiles that were made active with previous click
    if(document.querySelector(".selected") != null){
        clearActiveSelectedTiles();
    }

    const currentPosition = event.target.parentElement.id;
    const pieceColor = board[event.target.parentElement.id].color;
    const pieceType = board[event.target.parentElement.id].piece;

    //If piece is clicke mades it "selected" so it can be moved. Else stop function if empty tile was clicked
    if (event.target.parentElement.id != "") {
        event.target.parentElement.classList.add("selected");
    } else {
        return;
    }

    if(pieceColor != gameInfo.turn) {
        return;
    }

    let moves;
  
    switch(pieceType) {
        case("pawn"): 
            moves = movePawn(currentPosition, pieceColor);
            break;
        case("knight"): 
            moves = moveKnight(currentPosition, pieceColor);
            break;
        case("king"): 
            moves = moveKing(currentPosition, pieceColor);
            break;
        case("bishop"): 
            moves = moveBishop(currentPosition, pieceColor);
            break;
        case("rock"): 
            moves = moveRock(currentPosition, pieceColor);
            break;
        case("queen"): 
            moves = moveQueen(currentPosition, pieceColor);
            break;
    }
    
    const movesThatDontCauseCheck = checkIfMoved(currentPosition, pieceColor, moves);
    renderMoves(movesThatDontCauseCheck);
    

}

const tiles = document.querySelectorAll(".tile");
for (let i=0; i<tiles.length; i++) {
        tiles[i].addEventListener("click", pieceClicled);
}
